<!-- 

      stabchains.xml            genss package documentation
                                                                Max Neunhoeffer
                                                                   Felix Noeske

         Copyright (C) 2006-2009 by the authors.

This chapter explains how to work with stabiliser chains.

-->

<Chapter Label="StabChains">
<Heading>Stabiliser Chains</Heading>

This chapter describes the core functionality of the package. It mainly
covers how to use <Package>genss</Package> to compute stabiliser chains
for &GAP; groups and use them to do sifting.

<Section Label="StabChainComp">
<Heading>Computing stabiliser chains</Heading>

The main tool to compute a stabiliser chain is the following operation.
It has many options and can be customised in a very flexible way.

<ManSection>
<Oper Name="StabilizerChain" Arg="G [, opt]"/>
<Returns>a stabiliser chain object or <K>fail</K></Returns>
<Description>
This operation computes a stabiliser chain for the group <A>G</A> using a
randomised Schreier-Sims algorithm. The
second argument <A>opt</A> is an optional options record. See Section <Ref
Sect="StabChainOpts"/> below for an
explanation of the possible components. 
<P/>
Note that this is a Monte Carlo algorithm in most cases, so there is a
small error probability. However, the only error possible is that some of
the subgroups in the stabiliser chain are proper subgroups of the actual point
stabilisers. So the resulting group order is always a divisor of the actual
group order and if the two are equal, then the stabiliser chain is proved
to be correct. In particular, if the group object <A>G</A> for some reason
already knows the group order, then this procedure always returns a correct
and proven stabiliser chain for <A>G</A>.
</Description>
</ManSection>

</Section>

<Section Label="StabChainOpts">
<Heading>Options for the computation of stabiliser chains</Heading>

The options record for the <Ref Oper="StabilizerChain"/> can contain the
following components, which are used to control the behaviour of the
computation of a stabiliser chain for the group <A>G</A>.
Note that for most of these components there are default values to be found
in the global <C>GENSS</C> record. You can change these defaults there if
you want but you should know what you are doing. An explicitly given value
in the options record always takes precedence over the default value.

<List>
<Mark><C>Base</C></Mark>
<Item>This component can either be bound to an existing stabilizer chain
object or to a list of points. In both cases this indicates that the
base of the stabilizer chain or the list of points respectively are
known to be a base for the group <A>G</A>. In the first case the
corresponding action functions are taken from the stabiliser chain, in
the second case one should usually bind the component <C>BaseOps</C> to
a list of equal length containing the action functions corresponding to
the base points.
</Item>
<Mark><C>BaseOps</C></Mark>
<Item>If the <C>Base</C> component is bound to a list of points the
<C>BaseOps</C> component must be a list of equal length containing the
corresponding action functions. If the <C>BaseOps</C> component is unbound,
a list with identical entries <C>OnLines</C> is used in projective mode and
<C>OnPoints</C> in non-projective mode (see component <C>Projective</C>
below).
</Item>
<Mark><C>Cand</C></Mark>
<Item>The <C>Cand</C> component can be bound to a record <C>r</C>which contains
candidates for base points in the following way. The <C>r.points</C>
component contains the list of points, the <C>r.ops</C> component contains
a list of equal length with the corresponding action functions. The
points and actions specified in the <C>Cand</C> component are tried as
possible base points for <A>G</A> (and its stabilisers) first before other
points are guessed (see <Ref Oper="FindBasePointCandidates"/>). If a point
is fixed under all generators it is not used, unless the component
<C>Reduced</C> is explicitly set to <K>false</K> (see below). If the component
<C>StrictlyUseCandidates</C> is <K>false</K> (the default, see below), the
algorithm tries to use other points of an already found orbit before
considering the next candidate specified by <C>Cand</C>. This is usually 
sensible because for an already enumerated orbit we have a natural bound
on the length of the suborbits for the point stabiliser in this orbit.
</Item>
<Mark><C>DeterministicVerification</C></Mark>
<Item>
Set this component to <K>true</K> to switch on a deterministic verification
routine after the randomised Schreier-Sims procedure. This is not yet
implemented.
</Item>
<Mark><C>ErrorBound</C></Mark>
<Item>
Set this component to a rational number between 0 and 1. It will be an
upper bound for the error probability. That is, the error probability of
the Monte Carlo verification at the end will be less than this rational
number. This component overrides everything you specify in the
<C>random</C> or <C>VerifyElements</C> components.
</Item>
<Mark><C>FailInsteadOfError</C></Mark>
<Item>
If no short enough orbit is found during the computation, the procedure
stops with an error message. If you would rather like it to return
<K>fail</K> then set this component to <K>true</K>. This option can be used
to try an stabiliser chain computation automatically and give up before you
run out of memory.
</Item>
<Mark><C>ImmediateVerificationElements</C></Mark>
<Item>Whenever the randomised Schreier-Sims procedure has first computed
generators for a stabiliser in the chain and has computed a stabiliser
chain for that stabiliser recursively, 
an immediate verification is done. This is to spot early on that the
group found is in fact a proper subgroup of the stabiliser. This
verification is done by creating a few more random elements of that
stabiliser and sifting them through the newly created stabiliser chain.
Each such element has a chance of at least <M>1/2</M> to spot this. The
number of random elements used is stored in the component
<C>ImmediateVerificationElements</C>.
</Item>
<Mark><C>InitialHashSize</C></Mark>
<Item>
Set this component to the initial hash size for orbit computations in the
stabiliser chain.
</Item>
<Mark><C>IsOne</C></Mark>
<Item>
The default for this computation is the <Ref Oper="IsOne" BookName="Ref"/>
operation in the &GAP; library. Whenever in the stabiliser chain
computation it has to be tested whether or not a group element is equal to
the identity, the function stored in the <C>IsOne</C> component is called.
The rationale behind this is that you can compute a stabiliser chain for a
factor group of the group object <A>G</A>. For example, if you set the
<C>IsOne</C> component to <Ref Func="GENSS_IsOneProjective"/> for a matrix
group <A>G</A>, scalar multiples of the identity are considered to be
equal to the identity. You will have to specify the base points
explicitly using the <C>Cand</C> and <C>StrictlyUseCandidates</C>
component (see above and below) to only use actions
having the normal subgroup in its kernel. A shortcut for computing
stabiliser chains of projective groups (matrix group modulo scalars) is
to set the <C>Projective</C> component (see below) and switch to projective
mode.
</Item>
<Mark><C>LimitShortOrbCandidates</C></Mark>
<Item>
The integer value of this component limits the number of candidates
considered for the finding of short orbits. See the <C>TryShortOrbit</C>
and <C>TryBirthdayParadox</C> components.
</Item>
<Mark><C>NrRandElsBirthdayParadox</C></Mark>
<Item>
The method using the birthday paradox to find short orbits uses at most
as many random group elements to estimate the orbit size as this
component says. See the <C>TryBirthdayParadox</C> component.
</Item>
<Mark><C>NumberPrevOrbitPoints</C></Mark>
<Item>
After an orbit for the stabiliser chain has been enumerated, the randomised
Schreier-Sims method first tries <C>NumberPrevOrbitPoints</C> from this
orbit as next base points. Note that this is not done if the
<C>StrictlyUseCandidates</C> component is set to <K>true</K>.
</Item>
<Mark><C>OrbitLengthLimit</C></Mark>
<Item>This component is an absolute upper bound for the length of all
orbits in the stabiliser chain. If an orbit enumeration reaches this limit,
the stabiliser chain computation is aborted.
</Item>
<Mark><C>OrbitLimitBirthdayParadox</C></Mark>
<Item>
During the method to find short orbits using the birthday paradox (see
component <C>TryBirthdayParadox</C>) only orbits whose final estimated
length is less than <C>OrbitLimitBirthdayParadox</C> are used.
</Item>
<Mark><C>OrbitLimitImmediatelyTake</C></Mark>
<Item>
During the method to find short orbits using the birthday paradox (see
component <C>TryBirthdayParadox</C>) an orbit is immediately used
if its currently estimated length is less than
<C>OrbitLimitImmediatelyTake</C>, even if the estimate is not yet very
reliable.
</Item>
<Mark><C>Projective</C></Mark>
<Item>
Set this component to <K>true</K> if you want to compute a stabiliser chain
for a projective group given as a matrix group. Elements which are scalar
multiples of each other will be considered to be equal. This is achieved by
only considering projective actions. Note that in this case a known size 
of the group object cannot be used, since this size is the order of the
matrix group!
</Item>
<Mark><C>random</C></Mark>
<Item>
The <C>random</C> component is there as a compatibility option. It behaves
exactly as for the stabiliser chain methods in the &GAP; library. It must
be set to a number between <M>0</M> and <M>1000</M> indicating a lower
bound for the probability of a correct answer, where the value <M>a</M> means
<M>a/10</M>&percent;. Note that currently <M>1000</M> is not yet
implemented since there is no working deterministic verification routine.
</Item>
<Mark><C>RandomStabGens</C></Mark>
<Item>
This component contains the number of random stabiliser elements that are
generated initially to generate a new stabiliser in the chain.
</Item>
<Mark><C>Reduced</C></Mark>
<Item>
If this component is bound to <K>true</K>, then no orbits of length <M>1</M>
are allowed in the stabiliser chain. That is, no points are taken as base
points that are fixed under all generators of the current stabiliser.
Set this component to <K>false</K> to allow for orbits of length <M>1</M>,
for example if you want the stabiliser chain to run through a prescribed
base.
</Item>
<Mark><C>Report</C></Mark>
<Item>
The number in the <C>Report</C> component is taken as the <C>Report</C>
component in all orbit enumerations. That is, every <C>Report</C> 
newly found elements in the orbit a message is printed saying how 
far the computation has gone.
</Item>
<Mark><C>ShortOrbitsInitialLimit</C></Mark>
<Item>
See the <C>TryShortOrbit</C> component.
</Item>
<Mark><C>ShortOrbitsNrRandoms</C></Mark>
<Item>
See the <C>TryShortOrbit</C> component.
</Item>
<Mark><C>ShortOrbitsOrbLimit</C></Mark>
<Item>
See the <C>TryShortOrbit</C> component.
</Item>
<Mark><C>Size</C></Mark>
<Item>
If the <C>Size</C> component is set to a positive integer it is taken as
the size of the group <A>G</A>. This information allows to verify the
stabiliser chain simply by looking at its size. If the group object
knows its size already (and the <C>Projective</C> component was not set to
<K>true</K>), then the stored size of the group is automatically taken into
account, such that one does not have to use this option.
</Item>
<Mark><C>StabGenAddSlots</C></Mark>
<Item>
The value of the <C>StabGenAddSlots</C> component is directly handed over
to the product replacer object which is used to generate random elements to
find stabiliser generators.
</Item>
<Mark><C>StabGenMaxDepth</C></Mark>
<Item>
The value of the <C>StabGenMaxDepth</C> component is directly handed over
to the product replacer object which is used to generate random elements to
find stabiliser generators.
</Item>
<Mark><C>StabGenScrambleFactor</C></Mark>
<Item>
The value of the <C>StabGenScrambleFactor</C> component is directly handed over
to the product replacer object which is used to generate random elements to
find stabiliser generators.
</Item>
<Mark><C>StabGenScramble</C></Mark>
<Item>
The value of the <C>StabGenScramble</C> component is directly handed over
to the product replacer object which is used to generate random elements to
find stabiliser generators.
</Item>
<Mark><C>StrictlyUseCandidates</C></Mark>
<Item>
If this component is set to <K>true</K> (default is <K>false</K>) then
only the given candidate points are taken as possible base points. In
particular, the procedure does not take additional points of the previous
orbit as candidates for base points (see component
<C>NumberPrevOrbitPoints</C> ). Use this option in combination to
<C>Reduced</C> set to <K>false</K> to enforce a certain known base.
</Item>
<Mark><C>TryBirthdayParadox</C></Mark>
<Item>
The method to try to find short orbits using the birthday paradox is
used up to <C>TryBirthdayParadox</C> times for each new base point. This
method uses the Murray/O'Brien heuristics to find candidates for short
orbits and then uses statistics using the birthday paradox to estimate the
orbit lengths. As soon as a point is found whose orbit is either estimated
to be smaller than <C>OrbitLimitBirthdayParadox</C> with a solid
statistical estimate or is estimated to be smaller than
<C>OrbitLimitImmediatelyTake</C> with a weak statistical estimate, this
point is taken as the next base point.
</Item>
<Mark><C>TryShortOrbit</C></Mark>
<Item>
The method to try to find short orbits using the standard Murray/O'Brien
heuristics is used up to <C>TryShortOrbit</C> times for each new base
point. This method uses the heuristics to find candicates for short orbits
using <C>ShortOrbitsNrRandoms</C> random group elements.
It then enumerates all these orbits up to the limit
<C>ShortOrbitsInitialLimit</C>. If any of them closes the corresponding 
candidate is taken as the next base point. Otherwise half of the points are
thrown away and the limit is doubled. This goes on until either an orbit
closes or the limit grows over <C>ShortOrbitsOrbLimit</C>.
</Item>
<Mark><C>VerifyElements</C></Mark>
<Item>
This component can be used to set it to the number of random elements that
are used in the end to verify the stabiliser chain statistically.
Usually the user specifies the component <C>ErrorBound</C> instead
and <C>VerifyElements</C> is then computed automatically from that. 
However, if no <C>ErrorBound</C> is given, the <C>VerifyElements</C>
component takes precedence over the <C>random</C> component.
</Item>
<Mark><C>VeryShortOrbLimit</C></Mark>
<Item>
The very first method tried to find the next base point is to enumerate the
orbit of the first and the last basis vector and of one random vector
up to the limit <C>VeryShortOrbLimit</C>. If the orbit closes before this
limit is reached, the corresponding vector is immediately taken.
</Item>
</List>

<!-- This is an option for deterministic verification. Not yet active.
<Mark><C>MaxNumberSchreierGens</C></Mark>
<Item></Item>
<Mark><C>NumberSchreierGens</C></Mark>
<Item></Item>
-->
</Section>


<Section Label="UseStabChain">
<Heading>Using stabiliser chains</Heading>

The most important thing one can do with a stabiliser chain is sifting.
This is done with one of the next to operations:

<ManSection>
<Oper Name="SiftGroupElement" Arg="S, el"/>
<Returns>a record</Returns>
<Description>
The first argument <A>S</A> must be a stabiliser chain object and the 
second argument <A>el</A> a group element (not necessarily contained in the
group described by <A>S</A>). The result is a record describing the result
of the sifting process. The component <C>rem</C> contains the remainder of
the sifting process. If <A>el</A> is contained in the group described by
<A>S</A>, then the remainder is equal to the identity. Note that if
the <C>IsOne</C>-component of the options record for the stabiliser chain 
<A>S</A> is different from the <Ref Oper="IsOne"/> operation then the 
<C>rem</C> component is equal to the identity according to that test.
The result of this test (<K>true</K> or <K>false</K>) is stored in the
component <C>isone</C> of the resulting record. This means, that this
component indicates whether or not the sifting was successful. The
component <C>S</C> is bound to the stabiliser chain
object corresponding to the layer in which the sifting stopped. If it
ran through the whole chain this component is bound to <K>false</K>.
The component <C>preS</C> is always bound to the previous layer, which is
the lowest layer if the sifting was successful.
</Description>
</ManSection>

<ManSection>
<Oper Name="SiftGroupElementSLP" Arg="S, el"/>
<Returns>a record</Returns>
<Description>
This operation behaves exactly as <Ref Oper="SiftGroupElement"/> except that
in the successful case the component <C>slp</C> of the resulting record
is additionally bound to a straight line program which expresses the element
<A>el</A> in terms of the strong generators of the stabiliser chain
(see <Ref Oper="StrongGenerators"/>).
</Description>
</ManSection>

<ManSection>
<Oper Name="StrongGenerators" Arg="S"/>
<Returns>a list of group elements</Returns>
<Description>
This operation returns the strong generators of the stabiliser chain 
<A>S</A>. This means that each stabiliser in the stabiliser chain is
generated by the subset of the set of strong generators which fix
the corresponding points. Note that each layer of the stabiliser chain
uses some subset of these strong generators as generators for the 
orbit object of that layer.
</Description>
</ManSection>

<ManSection>
<Oper Name="NrStrongGenerators" Arg="S"/>
<Returns>a positive integer</Returns>
<Description>
This operation returns the number of strong generators of the stabiliser chain 
<A>S</A> (see <Ref Oper="StrongGenerators"/>).
</Description>
</ManSection>

<!--

BaseStabilizerChain
Size
Random (grp and stabchain)
\in
IsProved
MakeGAPStabChain
GroupIteratorByStabilizerChain
SetStabilizerChain
StoredStabilizerChain
SiftBaseImage
Stab
SetwiseStabilizer
SetwiseStabilizerPartitionBacktrack
FindShortGeneratorsOfSubgroup
BacktrackSearchStabilizerChainSubgroup
ComputeSuborbitsForStabilizerChain
BacktrackSearchStabilizerChainElement
FindBasePointCandidates
GENSS_IsOneProjective
SLPChainStabilizerChain
GroupHomomorphismByImagesNCStabilizerChain
VerifyStabilizerChainTC
VerifyStabilizerChainMC

<ManSection>
<Oper Name="" Arg=""/>
<Returns></K></Returns>
<Description>
</Description>
</ManSection>

-->

</Section>
<!-- ############################################################ -->

</Chapter>
