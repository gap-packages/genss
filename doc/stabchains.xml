<!-- 

      stabchains.xml            genss package documentation
                                                                Max Neunhoeffer
                                                                   Felix Noeske

         Copyright (C) 2006-2009 by the authors.

This chapter explains how to work with stabiliser chains.

-->

<Chapter Label="StabChains">
<Heading>Stabiliser Chains</Heading>

This chapter describes the core functionality of the package. It mainly
covers how to use <Package>genss</Package> to compute stabiliser chains
for &GAP; groups and use them to do sifting.

<Section Label="StabChainComp">
<Heading>Computing stabiliser chains</Heading>

The main tool to compute a stabiliser chain is the following operation.
It has many options and can be customised in a very flexible way.

<ManSection>
<Oper Name="StabilizerChain" Arg="G [, opt]"/>
<Returns>a stabiliser chain object or <K>fail</K></Returns>
<Description>
This operation computes a stabiliser chain for the group <A>G</A> using a
randomised Schreier-Sims algorithm. The
second argument <A>opt</A> is an optional options record. See Section <Ref
Sect="StabChainOpts"/> below for an
explanation of the possible components. 
<P/>
Note that this is a Monte Carlo algorithm in most cases, so there is a
small error probability. However, the only error possible is that some of
the subgroups in the stabiliser chain are subgroups of the actual point
stabilisers. So the resulting group order is always a divisor of the actual
group order and if the two are equal, then the stabiliser chain is proved
to be correct. In particular, if the group object <A>G</A> for some reason
already knows the group order, then this procedure always returns a correct
and proven stabiliser chain for <A>G</A>.
</Description>
</ManSection>

</Section>

<Section Label="StabChainOpts">
<Heading>Options for the computation of stabiliser chains</Heading>

The options record for the <Ref Oper="StabilizerChain"/> can contain the
following components, which are used to control the behaviour of the
computation of a stabiliser chain for the group <A>G</A>.
Note that for most of these components there are default values to be found
in the global <C>GENSS</C> record. You can change these defaults there if
you want but you should know what you are doing. An explicitly given value
in the options record always takes precedence over the default value.

<List>
<Mark><C>Base</C></Mark>
<Item>This component can either be bound to an existing stabilizer chain
object or to a list of points. In both cases this indicates that the
base of the stabilizer chain or the list of points respectively are
known to be a base for the group <A>G</A>. In the first case the
corresponding action functions are taken from the stabiliser chain, in
the second case one should usually bind the component <C>BaseOps</C> to
a list of equal length containing the action functions corresponding to
the base points.
</Item>
<Mark><C>BaseOps</C></Mark>
<Item>If the <C>Base</C> component is bound to a list of points the
<C>BaseOps</C> component must be a list of equal length containing the
corresponding action functions. If the <C>BaseOps</C> component is unbound,
a list with identical entries <C>OnLines</C> is used in projective mode and
<C>OnPoints</C> in non-projective mode (see component <C>Projective</C>
below).
</Item>
<Mark><C>Cand</C></Mark>
<Item>The <C>Cand</C> component can be bound to a record <C>r</C>which contains
candidates for base points in the following way. The <C>r.points</C>
component contains the list of points, the <C>r.ops</C> component contains
a list of equal length with the corresponding action functions. The
points and actions specified in the <C>Cand</C> component are tried as
possible base points for <A>G</A> (and its stabilisers) first before other
points are guessed (see <Ref Oper="FindBasePointCandidates"/>). If a point
is fixed under all generators it is not used, unless the component
<C>Reduced</C> is explicitly set to <K>false</K> (see below). If the component
<C>StrictlyUseCandidates</C> is <K>false</K> (the default, see below), the
algorithm tries to use other points of an already found orbit before
considering the next candidate specified by <C>Cand</C>. This is usually 
sensible because for an already enumerated orbit we have a natural bound
on the length of the suborbits for the point stabiliser in this orbit.
</Item>
<Mark><C>DeterministicVerification</C></Mark>
<Item>
Set this component to <K>true</K> to switch on a deterministic verification
routine after the randomised Schreier-Sims procedure. This is not yet
implemented.
</Item>
<Mark><C>ErrorBound</C></Mark>
<Item>
Set this component to a rational number between 0 and 1. It will be an
upper bound for the error probability. That is, the error probability of
the Monte Carlo verification at the end will be less than this rational
number. This component overrides everything you specify in the
<C>random</C> or <C>VerifyElements</C> components.
</Item>
<Mark><C>FailInsteadOfError</C></Mark>
<Item>
If no short enough orbit is found during the computation, the procedure
stops with an error message. If you would rather like it to return
<K>fail</K> then set this component to <K>true</K>. This option can be used
to try an stabiliser chain computation automatically and give up before you
run out of memory.
</Item>
<Mark><C>ImmediateVerificationElements</C></Mark>
<Item>Whenever the randomised Schreier-Sims procedure has first computed
generators for a stabiliser in the chain and has computed a stabiliser
chain for that stabiliser recursively, 
an immediate verification is done. This is to spot early on that the
group found is in fact a proper subgroup of the stabiliser. This
verification is done by creating a few more random elements of that
stabiliser and sifting them through the newly created stabiliser chain.
Each such element has a chance of at least <M>1/2</M> to spot this. The
number of random elements used is stored in the component
<C>ImmediateVerificationElements</C>.
</Item>
<Mark><C>InitialHashSize</C></Mark>
<Item>
Set this component to the initial hash size for orbit computations in the
stabiliser chain.
</Item>
<Mark><C>IsOne</C></Mark>
<Item>
The default for this computation is the <Ref Oper="IsOne" BookName="Ref"/>
operation in the &GAP; library. Whenever in the stabiliser chain
computation a group element has to be tested whether or not it is equal to
the identity, the function stored in the <C>IsOne</C> component is called.
The rationale behind this is that you can compute a stabiliser chain for a
factor group of the group object <A>G</A>. For example, if you set the
<C>IsOne</C> component to <Ref Func="GENSS_IsOneProjective"/> for a matrix
group <A>G</A> scalar multiples of the identity are considered to be
equal to the identity. You will have to specify the base points
explicitly using the <C>Cand</C> and <C>StrictlyUseCandidates</C>
component (see above and below) to only use actions
having the normal subgroup in its kernel. A shortcut for computing
stabiliser chains of projective groups (matrix group modulo scalars) is
to set the <C>Projective</C> component (see below) and switch to projective
mode.
</Item>
<Mark><C>LimitShortOrbCandidates</C></Mark>
<Item></Item>
<Mark><C>MaxNumberSchreierGens</C></Mark>
<Item></Item>
<Mark><C>NrRandElsBirthdayParadox</C></Mark>
<Item></Item>
<Mark><C>NumberPrevOrbitPoints</C></Mark>
<Item></Item>
<Mark><C>NumberSchreierGens</C></Mark>
<Item></Item>
<Mark><C>OrbitLengthLimit</C></Mark>
<Item></Item>
<Mark><C>OrbitLimitBirthdayParadox</C></Mark>
<Item></Item>
<Mark><C>OrbitLimitImmediatelyTake</C></Mark>
<Item></Item>
<Mark><C>Projective</C></Mark>
<Item></Item>
<Mark><C>random</C></Mark>
<Item></Item>
<Mark><C>RandomStabGens</C></Mark>
<Item></Item>
<Mark><C>Reduced</C></Mark>
<Item></Item>
<Mark><C>Report</C></Mark>
<Item></Item>
<Mark><C>ShortOrbitsInitialLimit</C></Mark>
<Item></Item>
<Mark><C>ShortOrbitsNrRandoms</C></Mark>
<Item></Item>
<Mark><C>ShortOrbitsOrbLimit</C></Mark>
<Item></Item>
<Mark><C>Size</C></Mark>
<Item></Item>
<Mark><C>StabAddSlots</C></Mark>
<Item></Item>
<Mark><C>StabAssumeCompleteLimit</C></Mark>
<Item></Item>
<Mark><C>StabGenAddSlots</C></Mark>
<Item></Item>
<Mark><C>StabGenMaxDepth</C></Mark>
<Item></Item>
<Mark><C>StabGenScrambleFactor</C></Mark>
<Item></Item>
<Mark><C>StabGenScramble</C></Mark>
<Item></Item>
<Mark><C>StabInitialLimit</C></Mark>
<Item></Item>
<Mark><C>StabInitialPatience</C></Mark>
<Item></Item>
<Mark><C>StabMaxDepth</C></Mark>
<Item></Item>
<Mark><C>StabOrbitLimit</C></Mark>
<Item></Item>
<Mark><C>StabScrambleFactor</C></Mark>
<Item></Item>
<Mark><C>StabScramble</C></Mark>
<Item></Item>
<Mark><C>StrictlyUseCandidates</C></Mark>
<Item></Item>
<Mark><C>TryBirthdayParadox</C></Mark>
<Item></Item>
<Mark><C>TryShortOrbit</C></Mark>
<Item></Item>
<Mark><C>VerifyElements</C></Mark>
<Item></Item>
<Mark><C>VeryShortOrbLimit</C></Mark>
<Item></Item>
</List>

</Section>


<Section Label="UseStabChain">
<Heading>Using stabiliser chains</Heading>

<!--

SiftGroupElement
SiftGroupElementSLP
StrongGenerators
NrStrongGenerators
SLPChainStabilizerChain
VerifyStabilizerChainTC
VerifyStabilizerChainMC
GroupHomomorphismByImagesNCStabilizerChain
Size
Random (grp and stabchain)
\in
IsProved
MakeGAPStabChain
GroupIteratorByStabilizerChain
BaseStabilizerChain
SiftBaseImage
SetStabilizerChain
StoredStabilizerChain
Stab
SetwiseStabilizer
SetwiseStabilizerPartitionBacktrack
FindShortGeneratorsOfSubgroup
BacktrackSearchStabilizerChainSubgroup
ComputeSuborbitsForStabilizerChain
BacktrackSearchStabilizerChainElement
FindBasePointCandidates
GENSS_IsOneProjective

<ManSection>
<Oper Name="" Arg=""/>
<Returns></K></Returns>
<Description>
</Description>
</ManSection>

-->

</Section>
<!-- ############################################################ -->

</Chapter>
